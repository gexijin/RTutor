
#____________________________________________________________________________
#  Exploratory Data Analysis
#____________________________________________________________________________


mod_10_eda_ui <- function(id) {

  ns <- NS(id)

  tagList(
      tabsetPanel(
        tabPanel(
          title = "Basic",
          div(style = "margin-left: 20px;",
            # First dataset
            uiOutput(ns("first_dataset_section")),
            # Second dataset
            uiOutput(ns("second_dataset_section"))
          )
        ),

        tabPanel(
          title = "Categorical",
          div(style = "margin-left: 20px;",
            hr(class = "custom-hr-thick"),
            h4(
              "Generated by the plot_bar() function in the",
              a(
                "DataExplorer",
                href = "https://cran.r-project.org/web/packages/DataExplorer/vignettes/dataexplorer-intro.html",
                target = "_blank"
              ),
              "package."
            ),
            # plotOutput(ns("distribution_category"))
            uiOutput(ns("distribution_category"))
          )
        ),
        tabPanel(
          title = "Numerical",
          div(style = "margin-left: 20px;",
            hr(class = "custom-hr-thick"),
            h4(
              "Generated by the plot_qq() and plot_histogram() functions in the",
              a(
                "DataExplorer",
                href = "https://cran.r-project.org/web/packages/DataExplorer/vignettes/dataexplorer-intro.html",
                target = "_blank"
              ),
              "package."
            ),
            # plotOutput(ns("qq_numeric")),
            # plotOutput(ns("distribution_numeric"))
            uiOutput(ns("qq_numeric")),
            uiOutput(ns("distribution_numeric"))
          )
        ),

        tabPanel(
          title = "Summary",
          div(style = "margin-left: 20px;",
            hr(class = "custom-hr-thick"),
            h4(
              "Generated by the ",
              a(
                "summarytools",
                href = "https://cran.r-project.org/web/packages/summarytools/vignettes/introduction.html",
                target = "_blank"
              ),
              "package using the command:summarytools::dfSummary(df)."
            ),
            verbatimTextOutput(ns("dfSummary"))
          )
        ),

        tabPanel(
          title = "Table1",
          div(style = "margin-left: 20px;",
            hr(class = "custom-hr-thick"),
            uiOutput(ns("table1_inputs")),
            h4(
              "Generated by the CreateTableOne() function in the",
              a(
                "tableone",
                href = "https://cran.r-project.org/web/packages/tableone/vignettes/introduction.html",
                target = "_blank"
              ),
              "package."
            ),
            verbatimTextOutput(ns("table1"))
          )
        ),

        tabPanel(
          title = "Correlation",
          div(style = "margin-left: 20px;",
            hr(class = "custom-hr-thick"),
            h4(
              "Generated by the corr_plot() function in the",
              a(
                "corrplot",
                href = "https://cran.r-project.org/web/packages/corrplot/vignettes/corrplot-intro.html",
                target = "_blank"
              ),
              "package. Blanks indicate no significant correlations."
            ),
            plotOutput(ns("corr_map"))
          )
        ),

        tabPanel(
          title = "GGpairs",
          div(style = "margin-left: 20px;",
            hr(class = "custom-hr-thick"),
            uiOutput(ns("ggpairs_inputs")),
            h4(""),
            h4(
              "Generated by the ggpairs() function in the",
              a(
                "GGally",
                href = "https://cran.r-project.org/web/packages/GGally/index.html",
                target = "_blank"
              ),
              "package."
            ),
            plotOutput(ns("ggpairs"))
          )
        ),

        tabPanel(
          title = "EDA Reports",
          div(style = "margin-left: 20px;",
            hr(class = "custom-hr-thick"),
            h4(strong("Comprehensive EDA (Exploratory Data Analysis)"),
              style = "font-size: 24px;"
            ),
            uiOutput(ns("eda_report_ui"))
          )
        )
      )
  )

}


mod_10_eda_serv <- function(id, selected_dataset_name, use_python,
                            current_data, current_data_2, ch) {

  moduleServer(id, function(input, output, session) {
    ns <- session$ns

    # GGPairs Data used for EDA
    ggpairs_data <- reactive({

      df <- current_data()
      # if analyses are run, use the original data
      if (length(ch$code_history) > 0) {
        df <- ch$code_history[[1]]$env$df
      }
      #df <- na.omit(df) # remove missing values
      cat_variables <- colnames(df)[!sapply(df, is.numeric)]
      # ggpairs does not tolerate variables with too many levels
      for (v in cat_variables) {
        counts <- sort(table(df[, v]), decreasing = TRUE)
        # more than 12 levels?
        if (length(counts) > max_eda_levels) {
          # if the top 12 levels represent more than 30% of the observations
          if (sum(counts[1:max_eda_levels]) / dim(df)[1] > 0.30) {

            df[, v] <- unlist(
              sapply(
                1:dim(df)[1],
                function(x) {
                  if (df[x, v] %in% names(counts)[1:max_eda_levels]) {
                    return(df[x, v])
                  } else {
                    return("Other")
                  }
                }
              )
            )
          } else {
            # too many levels, remove this column. Likely names
            df <- df[, !(colnames(df) %in% v)]
          }
        }
      }
      return(df)
    })



    ### EDA Visualizations ###

    ## Basic Panel ##
    # First Dataset
    # UI Elements
    output$first_dataset_section <- renderUI({
      req(!is.null(current_data()))

      tagList(
        hr(class = "custom-hr-thick"),
        div(
          fluidRow(
            column(
              width = 6,
              h4(strong("Data Structure: df")),
              div(
                style = "border: 1px solid #ccc; padding: 10px; height: 100%;",
                verbatimTextOutput(ns("data_structure"))
              )
            ),
            column(
              width = 6,
              div(
                style = "border: 1px solid #ccc; padding: 10px; height: 100%;",
                plotly::plotlyOutput(
                  ns("missing_values"),
                  width = "100%"
                )
              )
            )
          )
        ),
        br(),
        div(
          fluidRow(
            column(
              width = 12,
              h4(strong("Data Summary: df")),
              div(
                style = "border: 1px solid #ccc; padding: 10px;",
                verbatimTextOutput(ns("data_summary"))
              )
            )
          )
        )
      )
    })

    output$data_structure <- renderPrint({
      req(selected_dataset_name() != no_data)
      req(!is.null(current_data()))
      str(current_data())
    })

    output$data_summary <- renderText({
      req(selected_dataset_name() != no_data)
      req(!is.null(current_data()))
      options(width = 200) #Allow for wider visualization of summary()
      a <- paste(
        capture.output(
          summary(current_data())
        ),
        collapse = "\n"
      )
      options(width = 80) #Return to default visualization
      a
    })

    # plot missing values
    output$missing_values <- plotly::renderPlotly({
      req(!is.null(current_data()))

      # Check for missing values
      missing_count <- sum(is.na(current_data()))

      if (missing_count == 0) {
        # Create a plotly text plot when no missing values exist
        plotly::plot_ly() %>%
          plotly::add_text(
            x = 0.5,
            y = 0.5,
            text = "No Missing Values Detected",
            textfont = list(size = 20, color = "green")
          ) %>%
          plotly::layout(
            xaxis = list(
              showticklabels = FALSE,
              showgrid = FALSE,
              zeroline = FALSE
            ),
            yaxis = list(
              showticklabels = FALSE,
              showgrid = FALSE,
              zeroline = FALSE
            )
          )
      } else {
        # Your existing missing values plot
        p <- missing_values_plot(current_data())
        if (!is.null(p)) {
          plotly::ggplotly(p)
        } else {
          return(NULL)
        }
      }
    })

    # Second Dataset
    # UI Elements
    output$second_dataset_section <- renderUI({
      req(!is.null(current_data_2()))

      tagList(
        br(),
        hr(class = "custom-hr-thick"),
        div(
          fluidRow(
            column(width = 6,
              h4(strong("Data Structure: df2")),
              div(
                style = "border: 1px solid #ccc; padding: 10px;  height: 100%;",
                  verbatimTextOutput(ns("data_structure_2"))
                )
            ),
            column(width = 6,
              div(
                style = "border: 1px solid #ccc; padding: 10px; height: 100%;",
                plotly::plotlyOutput(
                  ns("missing_values_2"),
                  width = "100%"
                )
              )
            )
          )
        ),
        br(),
        div(
          fluidRow(
            column(width = 12,
              h4(strong("Data Summary: df2")),
              div(
                style = "border: 1px solid #ccc; padding: 10px;",
                verbatimTextOutput(ns("data_summary_2"))
              )
            )
          )
        )
      )
    })


    output$data_structure_2 <- renderPrint({
      req(!is.null(current_data_2()))
      str(current_data_2())
    })

    output$data_summary_2 <- renderText({
      req(!is.null(current_data_2()))
      options(width = 200) #Allow for wider visualization of summary()
      a <- paste(
        capture.output(
          summary(current_data_2())
        ),
        collapse = "\n"
      )
      options(width = 80) #Return to default visualization
      a
    })

    # plot missing values
    output$missing_values_2 <- plotly::renderPlotly({
      req(!is.null(current_data_2()))

      # Check for missing values
      missing_count <- sum(is.na(current_data_2()))

      if (missing_count == 0) {
        # Create a plotly text plot when no missing values exist
        plotly::plot_ly() %>%
          plotly::add_text(
            x = 0.5,
            y = 0.5,
            text = "No Missing Values Detected",
            textfont = list(size = 20, color = "green")
          ) %>%
          plotly::layout(
            xaxis = list(
              showticklabels = FALSE,
              showgrid = FALSE,
              zeroline = FALSE
            ),
            yaxis = list(
              showticklabels = FALSE,
              showgrid = FALSE,
              zeroline = FALSE
            )
          )
      } else {
        # Your existing missing values plot
        p <- missing_values_plot(current_data_2())
        if (!is.null(p)) {
          plotly::ggplotly(p)
        } else {
          return(NULL)
        }
      }
    })

    ## Categorical Panel ##
    output$dynamic_categorical_plot <- renderPlot({
      req(!is.null(current_data()))
      req(selected_dataset_name() != no_data)
        DataExplorer::plot_bar(current_data())
    })
    output$distribution_category <- renderUI({
      req(!is.null(current_data()))
      req(selected_dataset_name() != no_data)

      withProgress(message = "Barplots of categorical variables ...", {
        incProgress(0.3)

        # Calculate the number of categorical variables
        categorical_vars <- names(Filter(is.factor, current_data()))
        num_vars <- length(categorical_vars)
        
        # Set a base height, e.g., 400px, and add 100px per variable
        rows_needed <- ceiling(num_vars / 3)
        plot_height <- paste0(rows_needed * 400, "px")
        
        plotOutput(
          ns("dynamic_categorical_plot"), 
          width = "100%", 
          height = plot_height
        )
      })
    })


    ## Numerical Panel ##
    output$dynamic_numeric_plot <- renderPlot({
      req(!is.null(current_data()))
      req(selected_dataset_name() != no_data)
        DataExplorer::plot_histogram(current_data())
    })
    output$distribution_numeric <- renderUI({
      req(!is.null(current_data()))
      req(selected_dataset_name() != no_data)

      withProgress(message = "Creating histograms ...", {
        incProgress(0.3)

        # Calculate the number of categorical variables
        numeric_vars <- names(Filter(is.numeric, current_data()))
        num_vars <- length(numeric_vars)
        
        # Set a base height, e.g., 400px, and add 100px per variable
        rows_needed <- ceiling(num_vars / 4)
        plot_height <- paste0(rows_needed * 400, "px")
        
        plotOutput(
          ns("dynamic_numeric_plot"), 
          width = "100%", 
          height = plot_height
        )
      })
    })

    output$dynamic_qq_numeric <- renderPlot({
      req(!is.null(current_data()))
      req(selected_dataset_name() != no_data)
        DataExplorer::plot_qq(current_data())
    })
    output$qq_numeric  <- renderUI({
      req(!is.null(current_data()))
      req(selected_dataset_name() != no_data)

      withProgress(message = "Generating QQ plots ...", {
        incProgress(0.3)

        # Calculate the number of categorical variables
        numeric_vars <- names(Filter(is.numeric, current_data()))
        num_vars <- length(numeric_vars)
        
        # Set a base height, e.g., 400px, and add 100px per variable
        rows_needed <- ceiling(num_vars / 3)
        plot_height <- paste0(rows_needed * 400, "px")
        
        plotOutput(
          ns("dynamic_qq_numeric"), 
          width = "100%", 
          height = plot_height
        )
      })
    })


    ## Summary Panel ##
    output$dfSummary <- renderText({
      req(!is.null(current_data()))
      req(selected_dataset_name() != no_data)
      req(current_data())
      res <- capture.output(summarytools::dfSummary(current_data()))
      res <- paste(res, collapse = "\n")
      return(res)
    })


    ## Table1 Panel ##
    output$table1_inputs <- renderUI({
      req(!is.null(current_data()))
      req(selected_dataset_name() != no_data)
      req(ggpairs_data())
      df <- ggpairs_data()

      tags$div(
        class = "select-input-font",
        selectInput(
          inputId = ns("table1_strata"),
          label = "Select a category for strata",
          choices = colnames(df)[!sapply(df, is.numeric)],
          multiple = FALSE
        )
      )
    })

    output$table1 <- renderText({
      req(!is.null(current_data()))
      req(selected_dataset_name() != no_data)
      req(ggpairs_data())
      df <- ggpairs_data()

      # if more than 5000 rows, sample
      if (nrow(df) > 5000) {
        df <- df[sample(1:nrow(df), 5000), ]
      }
      req(input$table1_strata)
      options(width = 3000)
      withProgress(message = "Calculating table1 ...", {
        incProgress(0.3)
        ix <- match(input$table1_strata, colnames(df))
        res <- capture.output(
          tableone::CreateTableOne(
            vars = colnames(df)[-ix],
            data = df,
            strata = input$table1_strata
          )
        )
        res <- paste(res, collapse = "\n")
      })
      return(res)
    })


    ## Correlation Panel ##
    output$corr_map <- renderPlot({
      req(!is.null(current_data()))
      req(selected_dataset_name() != no_data)
      withProgress(message = "Generating correlation map ...", {
        incProgress(0.3)
        df <- current_data()
        df <- df[, sapply(df, is.numeric)]
        df <- na.omit(df) # remove missing values
        M <- cor(df)
        testRes <- corrplot::cor.mtest(df, conf.level = 0.95)
        corrplot::corrplot(
          M,
          p.mat = testRes$p,
          method = "circle",
          type = "lower",
          insig = "blank",
          addCoef.col = "black",
          number.cex = 0.8,
          order = "AOE",
          diag = FALSE
        )
      })
    })


    ## GGPairs Panel ##
    output$ggpairs_inputs <- renderUI({
      req(ggpairs_data())
      df <- ggpairs_data()
      selected <- colnames(df)
      if (length(selected) > 3) {
        selected <- sample(selected, 3)
      }
      tagList(
        fluidRow(
          column(
            width = 3,
            tags$div(
              class = "select-input-font",
              selectInput(
                inputId = ns("ggpairs_variables"),
                label = "Select variables",
                choices = colnames(df),
                multiple = TRUE,
                selected = selected
              )
            )
          ),
          column(
            width = 3,
            tags$div(
              class = "select-input-font",
              selectInput(
                inputId = ns("ggpairs_variables_color"),
                label = "Select a category for coloring",
                choices = colnames(df)[!sapply(df, is.numeric)],
                multiple = FALSE
              )
            )
          ),
          # add a submit button to refresh the plot
          column(
            width = 2,
            actionButton(
              inputId = ns("ggpairs_submit"),
              label = strong("Submit"),
              style = "margin-top: 15px;",
              class = "custom-action-button"
            )
          ),
          column(
            width = 4,
            h4("Please wait 1 minute for this plot to be created.")
          )
        )
      )
    })

    output$ggpairs <- renderPlot({
      req(selected_dataset_name() != no_data)
      req(ggpairs_data())
      req(input$ggpairs_submit)
      isolate({
        req(input$ggpairs_variables)
        req(length(input$ggpairs_variables) > 0)

        withProgress(message = "Running ggpairs ...", {
          incProgress(0.3)
          df <- as.data.frame(ggpairs_data())
          if (input$ggpairs_variables_color != "") {
            GGally::ggpairs(
              df[, input$ggpairs_variables],
              mapping = aes(
                color = df[, input$ggpairs_variables_color],
                alpha = 0.5
              )
            )
          } else {  # no color
            GGally::ggpairs(
              df[, input$ggpairs_variables]
            )
          }
        })
      })
    })


    ## EDA Panel ##

    # Variable Selection
    output$eda_report_ui <- renderUI({
      req(selected_dataset_name() != no_data)
      req(!use_python())
      req(!is.null(current_data()))
      df <- ggpairs_data()
      tagList(
        br(),
        fluidRow(
          column(
            width = 3,
            actionButton(
              inputId = ns("render_eda_report_rtutor"),
              label = strong("Render Report"),
              class = "custom-action-button"
            )
          )
        ),
        br(),
        tags$div(
          class = "select-input-font",
          selectInput(
            inputId = ns("eda_target_variable"),
            label = "Select a target variable (optional):",
            choices = c("<None>", colnames(df)),
            multiple = FALSE
          )
        ),
        br(),
        tags$div(
          class = "select-input-font",
          checkboxGroupInput(
            inputId = ns("eda_variables"),
            label = "Select up to 20 variables:",
            choices = colnames(df),
            selected = colnames(df)
          )
        )
      )
    })

    # Warning for User
    # if user selects more than 20 columns for the eda_variables,
    # only the first 20 is selected by eda_variables. Show a warning.
    observeEvent(c(input$eda_variables, input$eda_target_variable), {
      req(!use_python())
      req(!is.null(ggpairs_data()))

      selected_var <- input$eda_variables
      update_selection <- FALSE
      # if the selected target variable is not included in the eda_variables,
      # add it to the top of the list.
      if (input$eda_target_variable != "<None>" &&
            !(input$eda_target_variable %in% selected_var)) {
        selected_var <- c(input$eda_target_variable, selected_var)
        update_selection <- TRUE
      }

      if (length(selected_var) > max_eda_var) {
        selected_var <- selected_var[1:max_eda_var]

        showNotification(
          ui = paste("Only the first 20 variables are selected for EDA.
          Please deselect some variables to continue."),
          id = "eda_variables_warning",
          duration = 5,
          type = "error"
        )
        update_selection <- TRUE
      }

      # if target variable is selected, add to it;
      # if too many, only keep the first 20
      if (update_selection) {
        updateCheckboxGroupInput(
          session = session,
          inputId = ns("eda_variables"),
          label = "Deselect variables to ignore (optional):",
          choices = colnames(ggpairs_data()),
          selected = selected_var
        )
      }
    })


    # Write the EDA Report
    eda_file <- reactiveVal(NULL)

    observeEvent(input$render_eda_report_rtutor, {
      req(selected_dataset_name() != no_data)
      req(!use_python())
      req(!is.null(current_data()))


      withProgress(message = "Generating Report (5 minutes)", {
        incProgress(0.2)
        # Copy the report file to a temporary directory before processing it, in
        # case we don't have write permissions to the current working dir (which
        # can happen when deployed).
        tempReport <- file.path(tempdir(), "RTutor_EDA.Rmd")
        # tempReport
        tempReport <- gsub("\\", "/", tempReport, fixed = TRUE)
        output_file <- gsub("Rmd$", "html", tempReport)
        # This should retrieve the project location on your device:
        # "C:/Users/bdere/Documents/GitHub/idepGolem"
        # wd <- getwd()

        markdown_location <- app_sys("app/www/eda.Rmd")
        file.copy(from = markdown_location, to = tempReport, overwrite = TRUE)

        # Set up parameters to pass to Rmd document
        params <- list(
          df = ggpairs_data()[, input$eda_variables],
          target = input$eda_target_variable
        )
        req(params)
        # Knit the document, passing in the `params` list, and eval it in a
        # child of the global environment (this isolates the code in the
        # document from the code in this app).
        tryCatch({
          rmarkdown::render(
            input = tempReport, # markdown_location,
            output_file = output_file,
            params = params,
            envir = new.env(parent = globalenv())
          )
        },
        error = function(e) {
          showNotification(
            ui = paste("Error when generating the report. Please try again."),
            id = "eda_report_error",
            duration = 5,
            type = "error"
          )
        },
        finally = {
          eda_file(output_file)
          # show modal with download button
          showModal(modalDialog(
            title = "Successfully rendered the report!",
            downloadButton(
              outputId = ns("eda_report_rtutor"),
              label = "Download"
            ),
            easyClose = TRUE
          ))
        })
      })
    })

    # Report Download Handler
    output$eda_report_rtutor <- downloadHandler(
      # For PDF output, change this to "report.pdf"
      filename = "RTutor_EDA.html",
      content = function(file) {
        validate(
          need(!is.null(eda_file()), "File not found.")
        )
        file.copy(from = eda_file(), to = file, overwrite = TRUE)
      }
    )

  })
}